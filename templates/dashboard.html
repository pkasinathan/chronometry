<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronometry - Dashboard</title>
    
    <!-- Chart.js for analytics -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <!-- Socket.IO for real-time updates -->
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    
    <!-- Vue.js for reactive UI -->
    <script src="https://cdn.jsdelivr.net/npm/vue@3.3.8/dist/vue.global.prod.js"></script>
    
    <!-- Marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.0.0/marked.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow-x: hidden;
        }
        
        /* Header */
        .header {
            background: linear-gradient(180deg, #141414 0%, #0a0a0a 100%);
            padding: 24px 40px;
            border-bottom: 1px solid #222;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
        
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo-section {
            display: flex;
            align-items: center;
            gap: 16px;
        }
        
        .logo {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #E50914 0%, #b20710 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 26px;
            box-shadow: 0 4px 12px rgba(229, 9, 20, 0.4);
        }
        
        .header-title h1 {
            font-size: 24px;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 2px;
        }
        
        .header-subtitle {
            font-size: 13px;
            color: #8c8c8c;
        }
        
        .header-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .status-badge {
            padding: 8px 16px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 20px;
            font-size: 12px;
            color: #8c8c8c;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-badge.live {
            border-color: #E50914;
            color: #E50914;
        }
        
        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #E50914;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .btn {
            padding: 10px 20px;
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            color: #ffffff;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: #E50914;
            border-color: #E50914;
            transform: translateY(-1px);
        }
        
        .btn-primary {
            background: #E50914;
            border-color: #E50914;
        }
        
        .btn-primary:hover {
            background: #b20710;
        }
        
        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 32px 40px;
        }
        
        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 32px;
            border-bottom: 1px solid #222;
            padding-bottom: 0;
        }
        
        .nav-tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: #8c8c8c;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .nav-tab:hover {
            color: #ffffff;
        }
        
        .nav-tab.active {
            color: #E50914;
            border-bottom-color: #E50914;
        }
        
        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 32px;
        }
        
        .stat-card {
            background: #1a1a1a;
            border: 1px solid #222;
            border-radius: 12px;
            padding: 24px;
            transition: all 0.3s;
        }
        
        .stat-card:hover {
            border-color: #E50914;
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(229, 9, 20, 0.2);
        }
        
        .stat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }
        
        .stat-label {
            font-size: 12px;
            color: #8c8c8c;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
        }
        
        .stat-icon {
            font-size: 24px;
            opacity: 0.8;
        }
        
        .stat-value {
            font-size: 36px;
            font-weight: 700;
            color: #E50914;
            margin-bottom: 8px;
        }
        
        .stat-subtitle {
            font-size: 13px;
            color: #666;
        }
        
        /* Content Sections */
        .section {
            background: #1a1a1a;
            border: 1px solid #222;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }
        
        .section-title {
            font-size: 18px;
            font-weight: 700;
            color: #ffffff;
        }
        
        .section-actions {
            display: flex;
            gap: 8px;
        }
        
        /* Search Bar */
        .search-bar {
            display: flex;
            gap: 12px;
            margin-bottom: 24px;
        }
        
        .search-input {
            flex: 1;
            padding: 12px 16px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            color: #ffffff;
            font-size: 14px;
        }
        
        .search-input:focus {
            outline: none;
            border-color: #E50914;
        }
        
        .filter-select {
            padding: 12px 16px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
        }
        
        /* Activity List */
        .activity-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .activity-item {
            background: #0a0a0a;
            border: 1px solid #222;
            border-radius: 10px;
            padding: 16px 20px;
            display: flex;
            align-items: center;
            gap: 16px;
            transition: all 0.2s;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        
        .activity-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: var(--activity-color, #E50914);
            transition: width 0.2s;
        }
        
        .activity-item:hover {
            border-color: #333;
            transform: translateX(4px);
        }
        
        .activity-item:hover::before {
            width: 6px;
        }
        
        .activity-icon {
            font-size: 24px;
            min-width: 40px;
            text-align: center;
        }
        
        .activity-content {
            flex: 1;
        }
        
        .activity-title {
            font-size: 15px;
            font-weight: 600;
            color: #e5e5e5;
            margin-bottom: 4px;
        }
        
        .activity-summary {
            font-size: 13px;
            color: #8c8c8c;
            line-height: 1.5;
        }
        
        .activity-time {
            font-size: 12px;
            color: #666;
            font-weight: 500;
            min-width: 80px;
            text-align: right;
        }
        
        /* Charts */
        .chart-container {
            position: relative;
            height: 300px;
            margin: 20px 0;
        }
        
        /* Date Picker */
        .date-picker {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .date-input {
            padding: 10px 16px;
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            color: #ffffff;
            font-size: 14px;
        }
        
        /* Loading State */
        .loading {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #222;
            border-top-color: #E50914;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 16px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .header {
                padding: 16px 20px;
            }
            
            .container {
                padding: 20px;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .header-actions {
                display: none;
            }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: #0a0a0a;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #E50914;
            border-radius: 5px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #b20710;
        }
        
        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }
        
        .modal-content {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 12px;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }
        
        .modal-header {
            padding: 24px;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            font-size: 20px;
            font-weight: 700;
            color: #E50914;
        }
        
        .modal-close {
            background: transparent;
            border: none;
            color: #8c8c8c;
            font-size: 28px;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .modal-close:hover {
            background: #2a2a2a;
            color: #ffffff;
        }
        
        .modal-body {
            padding: 24px;
        }
        
        .modal-info {
            margin-bottom: 20px;
        }
        
        .modal-info-row {
            display: flex;
            gap: 12px;
            margin-bottom: 12px;
            font-size: 14px;
        }
        
        .modal-info-label {
            color: #8c8c8c;
            min-width: 100px;
        }
        
        .modal-info-value {
            color: #ffffff;
        }
        
        .modal-screenshot {
            width: 100%;
            border-radius: 8px;
            border: 1px solid #222;
        }
        
        .modal-frames {
            margin-top: 20px;
        }
        
        .modal-frames-title {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin-bottom: 12px;
        }
        
        .frames-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 12px;
        }
        
        .frame-thumbnail {
            width: 100%;
            height: 100px;
            object-fit: cover;
            border-radius: 6px;
            border: 1px solid #222;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .frame-thumbnail:hover {
            border-color: #E50914;
            transform: scale(1.05);
        }
        
        /* Digest Styles */
        .digest-container {
            display: flex;
            flex-direction: column;
            gap: 28px;
        }
        
        .digest-section-title {
            font-size: 16px;
            font-weight: 700;
            color: #ffffff;
            margin-bottom: 16px;
            letter-spacing: -0.3px;
        }
        
        .digest-overall {
            background: linear-gradient(135deg, #1a1a1a 0%, #0f0f0f 100%);
            border: 1px solid #2a2a2a;
            border-radius: 12px;
            padding: 24px;
        }
        
        .digest-overall-text {
            font-size: 15px;
            line-height: 1.8;
            color: #e5e5e5;
            margin: 0;
        }
        
        .digest-categories {
            background: #0a0a0a;
            border-radius: 12px;
            padding: 24px;
        }
        
        .digest-category-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        
        .digest-category-card {
            background: #141414;
            border: 1px solid #2a2a2a;
            border-left: 3px solid var(--category-color, #E50914);
            border-radius: 8px;
            padding: 20px;
            transition: all 0.2s ease;
        }
        
        .digest-category-card:hover {
            transform: translateX(4px);
            border-color: var(--category-color, #E50914);
            box-shadow: 0 4px 12px rgba(229, 9, 20, 0.15);
        }
        
        .digest-category-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .digest-category-icon {
            font-size: 24px;
        }
        
        .digest-category-name {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            flex-shrink: 0;
        }
        
        .digest-category-stats {
            font-size: 12px;
            color: #8c8c8c;
            margin-left: auto;
        }
        
        .digest-category-summary {
            font-size: 14px;
            line-height: 1.7;
            color: #b3b3b3;
            margin: 0;
            padding-left: 36px;
        }
        
        /* Settings Containers */
        .settings-container {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            overflow: hidden;
            transition: all 0.2s ease;
        }
        
        .settings-container:hover {
            border-color: #333;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .settings-container-header {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 20px 24px;
            background: linear-gradient(135deg, #141414 0%, #0f0f0f 100%);
            border-bottom: 1px solid #2a2a2a;
        }
        
        .settings-container-icon {
            font-size: 24px;
        }
        
        .settings-container-title {
            font-size: 16px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }
        
        .settings-container-body {
            padding: 24px;
            display: grid;
            gap: 20px;
        }
        
        .settings-field {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .settings-label {
            font-size: 13px;
            font-weight: 500;
            color: #e5e5e5;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .settings-input {
            padding: 12px 16px;
            background: #141414;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            color: #ffffff;
            font-size: 14px;
            max-width: 400px;
            transition: all 0.2s;
        }
        
        .settings-input:focus {
            outline: none;
            border-color: #E50914;
            background: #1a1a1a;
        }
        
        .settings-input:hover {
            border-color: #333;
        }
        
        .settings-hint {
            font-size: 12px;
            color: #666;
            line-height: 1.5;
        }
        
        .settings-checkbox-label {
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: pointer;
            font-size: 14px;
            color: #e5e5e5;
        }
        
        .settings-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #E50914;
        }
        
        /* Inline Activity Details */
        .activity-details {
            background: #0f0f0f;
            border: 1px solid #2a2a2a;
            border-top: none;
            border-radius: 0 0 10px 10px;
            padding: 20px;
            margin-top: -12px;
            margin-bottom: 12px;
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
                padding: 0 20px;
            }
            to {
                opacity: 1;
                max-height: 1000px;
                padding: 20px;
            }
        }
        
        .activity-details-header {
            display: flex;
            gap: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid #222;
            margin-bottom: 16px;
            font-size: 13px;
            color: #b3b3b3;
            flex-wrap: wrap;
        }
        
        .activity-details-header strong {
            color: #8c8c8c;
            font-weight: 600;
        }
        
        .activity-details-summary {
            font-size: 14px;
            line-height: 1.6;
            color: #e5e5e5;
            margin-bottom: 20px;
        }
        
        .activity-details-summary strong {
            color: #E50914;
            font-weight: 600;
            display: block;
            margin-bottom: 8px;
        }
        
        .activity-details-images {
            margin-top: 20px;
        }
        
        .activity-frames-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
        }
        
        .activity-frame-image {
            width: 100%;
            height: 140px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid #2a2a2a;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .activity-frame-image:hover {
            border-color: #E50914;
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(229, 9, 20, 0.3);
        }
        
        .activity-details-loading {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 20px;
            color: #666;
            font-size: 13px;
        }
        
        .activity-details-loading .loading-spinner {
            width: 20px;
            height: 20px;
            margin: 0;
        }
        
        /* Markdown Formatting Styles */
        .markdown-content {
            line-height: 1.6;
        }
        
        .markdown-content p {
            margin-bottom: 12px;
        }
        
        .markdown-content p:last-child {
            margin-bottom: 0;
        }
        
        .markdown-content strong {
            font-weight: 700;
            color: #ffffff;
        }
        
        .markdown-content em {
            font-style: italic;
            color: #e5e5e5;
        }
        
        .markdown-content h1,
        .markdown-content h2,
        .markdown-content h3,
        .markdown-content h4 {
            color: #E50914;
            margin-top: 16px;
            margin-bottom: 12px;
            font-weight: 700;
        }
        
        .markdown-content h1 { font-size: 20px; }
        .markdown-content h2 { font-size: 18px; }
        .markdown-content h3 { font-size: 16px; }
        .markdown-content h4 { font-size: 14px; }
        
        .markdown-content ol,
        .markdown-content ul {
            margin-left: 24px;
            margin-bottom: 12px;
        }
        
        .markdown-content li {
            margin-bottom: 6px;
            color: #e5e5e5;
        }
        
        .markdown-content code {
            background: #0a0a0a;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 0.9em;
            color: #E50914;
            border: 1px solid #2a2a2a;
        }
        
        .markdown-content pre {
            background: #0a0a0a;
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #2a2a2a;
            overflow-x: auto;
            margin-bottom: 12px;
        }
        
        .markdown-content pre code {
            background: transparent;
            padding: 0;
            border: none;
        }
        
        .markdown-content blockquote {
            border-left: 3px solid #E50914;
            padding-left: 16px;
            margin-left: 0;
            margin-bottom: 12px;
            color: #b3b3b3;
            font-style: italic;
        }
        
        .markdown-content a {
            color: #E50914;
            text-decoration: none;
        }
        
        .markdown-content a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <div class="header">
            <div class="header-content">
                <div class="logo-section">
                    <div class="logo">‚è±Ô∏è</div>
                    <div class="header-title">
                        <h1>Chronometry</h1>
                        <div class="header-subtitle">[[ formattedSelectedDate ]]</div>
                    </div>
                </div>
                
                <div class="header-actions">
                    <div class="status-badge" :class="{ live: isLive }">
                        <span class="status-indicator" v-if="isLive"></span>
                        [[ isLive ? 'Live' : 'Offline' ]]
                    </div>
                    <button class="btn" @click="refresh">üîÑ Refresh</button>
                    <button class="btn btn-primary" @click="exportData">üìä Export</button>
                </div>
            </div>
        </div>
        
        <!-- Main Content -->
        <div class="container">
            <!-- Navigation Tabs -->
            <div class="nav-tabs">
                <button class="nav-tab" :class="{ active: activeTab === 'dashboard' }" @click="activeTab = 'dashboard'">
                    üìä Dashboard
                </button>
                <button class="nav-tab" :class="{ active: activeTab === 'timeline' }" @click="activeTab = 'timeline'">
                    üìÖ Timeline
                </button>
                <button class="nav-tab" :class="{ active: activeTab === 'analytics' }" @click="activeTab = 'analytics'">
                    üìà Analytics
                </button>
                <button class="nav-tab" :class="{ active: activeTab === 'search' }" @click="activeTab = 'search'">
                    üîç Search
                </button>
                <button class="nav-tab" :class="{ active: activeTab === 'settings' }" @click="activeTab = 'settings'">
                    ‚öôÔ∏è Settings
                </button>
            </div>
            
            <!-- Dashboard Tab -->
            <div v-show="activeTab === 'dashboard'">
                <!-- Stats Grid -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-header">
                            <div class="stat-label">Total Days</div>
                            <div class="stat-icon">üìÖ</div>
                        </div>
                        <div class="stat-value">[[ stats.total_days ]]</div>
                        <div class="stat-subtitle">Days tracked</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-header">
                            <div class="stat-label">Total Frames</div>
                            <div class="stat-icon">üì∏</div>
                        </div>
                        <div class="stat-value">[[ stats.total_frames ]]</div>
                        <div class="stat-subtitle">Screenshots captured</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-header">
                            <div class="stat-label">Activities</div>
                            <div class="stat-icon">üíº</div>
                        </div>
                        <div class="stat-value">[[ stats.total_activities ]]</div>
                        <div class="stat-subtitle">Total activities tracked</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-header">
                            <div class="stat-label">Focus Score</div>
                            <div class="stat-icon">üéØ</div>
                        </div>
                        <div class="stat-value">[[ stats.average_focus ]]%</div>
                        <div class="stat-subtitle">Average focus percentage</div>
                    </div>
                </div>
                
                <!-- Digest -->
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">üìã Digest</h2>
                        <div class="section-actions">
                            <div class="date-picker">
                                <input type="date" v-model="digestDate" @change="loadDigest" class="date-input">
                                <button class="btn" @click="previousDigestDay">‚Äπ Prev</button>
                                <button class="btn" @click="nextDigestDay">Next ‚Ä∫</button>
                            </div>
                            <button class="btn" @click="regenerateDigest" title="Regenerate digest">üîÑ Regenerate</button>
                            <button class="btn" @click="activeTab = 'timeline'">View Details</button>
                        </div>
                    </div>
                    
                    <div class="loading" v-if="loadingDigest">
                        <div class="loading-spinner"></div>
                        <div>Generating digest...</div>
                    </div>
                    
                    <div class="digest-container" v-else-if="digest && !digest.error">
                        <!-- Overall Summary -->
                        <div class="digest-overall">
                            <h3 class="digest-section-title">Summary</h3>
                            <div class="digest-overall-text markdown-content" v-html="renderMarkdown(digest.overall_summary)"></div>
                        </div>
                        
                        <!-- Category Summaries -->
                        <div class="digest-categories">
                            <h3 class="digest-section-title">Activity Breakdown</h3>
                            <div class="digest-category-list">
                                <div v-for="(data, category) in digest.category_summaries" 
                                     :key="category"
                                     class="digest-category-card"
                                     :style="{ '--category-color': data.color }">
                                    <div class="digest-category-header">
                                        <span class="digest-category-icon">[[ data.icon ]]</span>
                                        <span class="digest-category-name">[[ category ]]</span>
                                        <span class="digest-category-stats">
                                            [[ data.count ]] activities ¬∑ [[ formatDuration(data.duration_minutes) ]]
                                        </span>
                                    </div>
                                    <div class="digest-category-summary markdown-content" v-html="renderMarkdown(data.summary)"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="empty-state" v-else>
                        <div class="empty-state-icon">üì≠</div>
                        <div>[[ digest?.error || 'No activities recorded yet today' ]]</div>
                    </div>
                </div>
            </div>
            
            <!-- Timeline Tab -->
            <div v-show="activeTab === 'timeline'">
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">Activity Timeline</h2>
                        <div class="date-picker">
                            <input type="date" v-model="selectedDate" @change="loadTimelineByDate" class="date-input">
                            <button class="btn" @click="previousDay">‚Äπ Prev</button>
                            <button class="btn" @click="nextDay">Next ‚Ä∫</button>
                        </div>
                    </div>
                    
                    <div class="loading" v-if="loadingTimeline">
                        <div class="loading-spinner"></div>
                        <div>Loading timeline...</div>
                    </div>
                    
                    <div v-else-if="timelineActivities.length > 0">
                        <div class="activity-list">
                            <div v-for="(activity, index) in timelineActivities" :key="activity.start_time">
                                <div class="activity-item"
                                     :style="{ '--activity-color': activity.color }"
                                     @click="toggleActivityExpand(index)">
                                    <div class="activity-icon">[[ activity.icon ]]</div>
                                    <div class="activity-content">
                                        <div class="activity-title">[[ activity.category ]]</div>
                                        <div class="activity-summary markdown-content" v-html="renderMarkdown(activity.summary)"></div>
                                    </div>
                                    <div class="activity-time">[[ formatTime(activity.start_time) ]] - [[ formatDuration(activity.duration_minutes) ]]</div>
                                </div>
                                
                                <!-- Expanded inline details -->
                                <div v-if="expandedActivity === index" class="activity-details">
                                    <div class="activity-details-header">
                                        <span><strong>Category:</strong> [[ activity.category ]]</span>
                                        <span><strong>Date:</strong> [[ formatDateTime(activity.start_time) ]]</span>
                                        <span><strong>Duration:</strong> [[ formatDuration(activity.duration_minutes) ]]</span>
                                    </div>
                                    <div v-if="activityFrames.length > 0" class="activity-details-images">
                                        <div class="activity-frames-grid">
                                            <img v-for="frame in activityFrames" :key="frame.timestamp"
                                                 :src="getFrameImageUrl(frame)"
                                                 :alt="frame.timestamp"
                                                 class="activity-frame-image"
                                                 @click="viewFrameFullSize(frame)">
                                        </div>
                                    </div>
                                    <div v-else-if="loadingFrames" class="activity-details-loading">
                                        <div class="loading-spinner"></div>
                                        <span>Loading screenshots...</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="empty-state" v-else>
                        <div class="empty-state-icon">üìÖ</div>
                        <div>No activities found for this date</div>
                    </div>
                </div>
            </div>
            
            <!-- Analytics Tab -->
            <div v-show="activeTab === 'analytics'">
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">Productivity Analytics</h2>
                        <select v-model="analyticsDays" @change="loadAnalytics" class="filter-select">
                            <option value="7">Last 7 days</option>
                            <option value="14">Last 14 days</option>
                            <option value="30">Last 30 days</option>
                        </select>
                    </div>
                    
                    <div class="chart-container">
                        <canvas id="focusChart"></canvas>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">API Token Usage</h2>
                    <div class="chart-container">
                        <canvas id="tokenChart"></canvas>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Category Breakdown</h2>
                    <div class="chart-container">
                        <canvas id="categoryChart"></canvas>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">Hourly Activity Pattern</h2>
                    <div class="chart-container">
                        <canvas id="hourlyChart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Search Tab -->
            <div v-show="activeTab === 'search'">
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">Search Activities</h2>
                    </div>
                    
                    <div class="search-bar">
                        <input type="text" v-model="searchQuery" @input="debounceSearch" 
                               class="search-input" placeholder="Search activities...">
                        <select v-model="searchCategory" @change="performSearch" class="filter-select">
                            <option value="">All Categories</option>
                            <option value="code">Code</option>
                            <option value="meeting">Meeting</option>
                            <option value="documentation">Documentation</option>
                            <option value="email">Email</option>
                            <option value="browsing">Browsing</option>
                        </select>
                        <button class="btn btn-primary" @click="performSearch">Search</button>
                    </div>
                    
                    <div class="loading" v-if="searchLoading">
                        <div class="loading-spinner"></div>
                        <div>Searching...</div>
                    </div>
                    
                    <div v-else-if="searchResults.length > 0">
                        <div style="margin-bottom: 16px; color: #8c8c8c;">
                            Found [[ searchResults.length ]] result(s)
                        </div>
                        <div class="activity-list">
                            <div v-for="result in searchResults" :key="result.start_time"
                                 class="activity-item"
                                 :style="{ '--activity-color': result.color }">
                                <div class="activity-icon">[[ result.icon ]]</div>
                                <div class="activity-content">
                                    <div class="activity-title">[[ result.category ]] - [[ result.date ]]</div>
                                    <div class="activity-summary markdown-content" v-html="renderMarkdown(result.summary)"></div>
                                </div>
                                <div class="activity-time">[[ formatDuration(result.duration_minutes) ]]</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="empty-state" v-else-if="searchQuery">
                        <div class="empty-state-icon">üîç</div>
                        <div>No results found for "[[ searchQuery ]]"</div>
                    </div>
                </div>
            </div>
            
            <!-- Settings Tab -->
            <div v-show="activeTab === 'settings'">
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">‚öôÔ∏è Configuration Settings</h2>
                        <button class="btn btn-primary" @click="saveSettings">üíæ Save Changes</button>
                    </div>
                    
                    <div style="display: grid; gap: 20px;">
                        <!-- Capture Settings Container -->
                        <div class="settings-container">
                            <div class="settings-container-header">
                                <span class="settings-container-icon">üì∏</span>
                                <h3 class="settings-container-title">Capture Settings</h3>
                            </div>
                            <div class="settings-container-body">
                                <div class="settings-field">
                                    <label class="settings-label">Capture Interval (seconds)</label>
                                    <input type="number" v-model.number="settings.capture.capture_interval_seconds" 
                                           class="settings-input">
                                    <div class="settings-hint">
                                        Current: 1 capture every [[ settings.capture.capture_interval_seconds ]] seconds ([[ Math.round(settings.capture.capture_interval_seconds / 60) ]] minutes)
                                        <br>Examples: 900 = 15 min, 600 = 10 min, 1800 = 30 min
                                    </div>
                                </div>
                                
                                <div class="settings-field">
                                    <label class="settings-label">Monitor Index</label>
                                    <input type="number" v-model.number="settings.capture.monitor_index" 
                                           class="settings-input">
                                    <div class="settings-hint">
                                        Which monitor to capture (0 = all monitors, 1+ = specific monitor)
                                    </div>
                                </div>
                                
                                <div class="settings-field">
                                    <label class="settings-label">Retention Days</label>
                                    <input type="number" v-model.number="settings.capture.retention_days" 
                                           class="settings-input">
                                    <div class="settings-hint">
                                        Number of days to keep screenshots before auto-deletion
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Annotation Settings Container -->
                        <div class="settings-container">
                            <div class="settings-container-header">
                                <span class="settings-container-icon">ü§ñ</span>
                                <h3 class="settings-container-title">Annotation Settings</h3>
                            </div>
                            <div class="settings-container-body">
                                <div class="settings-field">
                                    <label class="settings-label">Batch Size</label>
                                    <input type="number" v-model.number="settings.annotation.batch_size" 
                                           class="settings-input">
                                    <div class="settings-hint">
                                        Number of images to batch together for AI analysis<br>
                                        Higher = more context but slower processing
                                    </div>
                                </div>
                                
                                <div class="settings-field">
                                    <label class="settings-label">AI Prompt</label>
                                    <textarea v-model="settings.annotation.prompt" 
                                              class="settings-input" 
                                              rows="4"
                                              style="resize: vertical; font-family: inherit;"></textarea>
                                    <div class="settings-hint">
                                        Customize how AI analyzes your screenshots
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Timeline Settings Container -->
                        <div class="settings-container">
                            <div class="settings-container-header">
                                <span class="settings-container-icon">üìÖ</span>
                                <h3 class="settings-container-title">Timeline Settings</h3>
                            </div>
                            <div class="settings-container-body">
                                <div class="settings-field">
                                    <label class="settings-label">Bucket Minutes</label>
                                    <input type="number" v-model.number="settings.timeline.bucket_minutes" 
                                           class="settings-input">
                                    <div class="settings-hint">
                                        Time window (in minutes) for grouping similar activities together
                                    </div>
                                </div>
                                
                                <div class="settings-field">
                                    <label class="settings-label">Exclude Keywords</label>
                                    <textarea v-model="settings.timeline.exclude_keywords_text" 
                                              class="settings-input" 
                                              rows="2"
                                              placeholder="youtube, reddit, twitter"
                                              style="resize: vertical; font-family: inherit;"></textarea>
                                    <div class="settings-hint">
                                        Comma-separated keywords to hide from timeline (case-insensitive)
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Notifications Settings Container -->
                        <div class="settings-container">
                            <div class="settings-container-header">
                                <span class="settings-container-icon">üîî</span>
                                <h3 class="settings-container-title">Notification Settings</h3>
                            </div>
                            <div class="settings-container-body">
                                <div class="settings-field">
                                    <label class="settings-checkbox-label">
                                        <input type="checkbox" v-model="settings.notifications.enabled" class="settings-checkbox">
                                        <span>Enable Desktop Notifications</span>
                                    </label>
                                    <div class="settings-hint">
                                        Show system notifications for captures and events
                                    </div>
                                </div>
                                
                                <div class="settings-field">
                                    <label class="settings-checkbox-label">
                                        <input type="checkbox" v-model="settings.notifications.notify_before_capture" class="settings-checkbox">
                                        <span>Notify Before Each Capture</span>
                                    </label>
                                    <div class="settings-hint">
                                        Show a notification before taking each screenshot
                                    </div>
                                </div>
                                
                                <div class="settings-field">
                                    <label class="settings-label">Pre-Capture Warning Time (seconds)</label>
                                    <input type="number" v-model.number="settings.notifications.pre_capture_warning_seconds" 
                                           class="settings-input" min="0" max="30" step="1">
                                    <div class="settings-hint">
                                        How many seconds before each capture to show a warning notification<br>
                                        Set to 0 to disable. Recommended: 5 seconds to hide sensitive data
                                    </div>
                                </div>
                                
                                <div class="settings-field">
                                    <label class="settings-checkbox-label">
                                        <input type="checkbox" v-model="settings.notifications.pre_capture_sound" class="settings-checkbox">
                                        <span>Play Sound on Pre-Capture Warning</span>
                                    </label>
                                    <div class="settings-hint">
                                        Play an audio alert when showing the pre-capture warning
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Digest Settings Container -->
                        <div class="settings-container">
                            <div class="settings-container-header">
                                <span class="settings-container-icon">üìã</span>
                                <h3 class="settings-container-title">Digest Settings</h3>
                            </div>
                            <div class="settings-container-body">
                                <div class="settings-field">
                                    <label class="settings-label">Generation Interval (seconds)</label>
                                    <input type="number" v-model.number="settings.digest.interval_seconds" 
                                           class="settings-input">
                                    <div class="settings-hint">
                                        Current: Generate every [[ Math.round(settings.digest.interval_seconds / 60) ]] minutes<br>
                                        Examples: 3600 = 1 hour, 7200 = 2 hours, 1800 = 30 minutes
                                    </div>
                                </div>
                                
                                <div class="settings-field">
                                    <label class="settings-label">NCP Project Name</label>
                                    <input type="text" v-model="settings.digest.ncp_project_id" 
                                           class="settings-input">
                                    <div class="settings-hint">
                                        Netflix Copilot Project ID used for digest generation API calls
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="section-header">
                        <h2 class="section-title">üìÖ Available Dates</h2>
                    </div>
                    
                    <div class="activity-list">
                        <div v-for="dateInfo in availableDates" :key="dateInfo.date"
                             class="activity-item" @click="viewDate(dateInfo.date)">
                            <div class="activity-icon">üìÖ</div>
                            <div class="activity-content">
                                <div class="activity-title">[[ dateInfo.date ]]</div>
                                <div class="activity-summary">[[ dateInfo.frame_count ]] frames captured</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
    </div>
    
    <script>
        const { createApp } = Vue;
        
        createApp({
            delimiters: ['[[', ']]'],
            data() {
                return {
                    activeTab: 'dashboard',
                    isLive: false,
                    loading: false,
                    loadingTimeline: false,
                    searchLoading: false,
                    currentDate: new Date().toLocaleDateString('en-US', { 
                        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
                    }),
                    selectedDate: (() => {
                        const now = new Date();
                        const year = now.getFullYear();
                        const month = String(now.getMonth() + 1).padStart(2, '0');
                        const day = String(now.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    })(),
                    digestDate: (() => {
                        const now = new Date();
                        const year = now.getFullYear();
                        const month = String(now.getMonth() + 1).padStart(2, '0');
                        const day = String(now.getDate()).padStart(2, '0');
                        return `${year}-${month}-${day}`;
                    })(),
                    analyticsDays: 7,
                    stats: {
                        total_days: 0,
                        total_frames: 0,
                        total_activities: 0,
                        average_focus: 0
                    },
                    todayActivities: [],
                    timelineActivities: [],
                    digest: null,
                    loadingDigest: false,
                    searchQuery: '',
                    searchCategory: '',
                    searchResults: [],
                    settings: {
                        capture: {
                            capture_interval_seconds: 900,
                            monitor_index: 1,
                            retention_days: 1095
                        },
                        annotation: {
                            batch_size: 4,
                            prompt: 'Summarize the type of task or activity shown in these images using clear, work-related terms.'
                        },
                        timeline: {
                            bucket_minutes: 30,
                            exclude_keywords_text: ''  // Comma-separated text, converted to/from array
                        },
                        digest: {
                            interval_seconds: 3600,
                            ncp_project_id: 'pkasichronometry'
                        },
                        notifications: {
                            enabled: true,
                            notify_before_capture: true,
                            pre_capture_warning_seconds: 5,
                            pre_capture_sound: false
                        }
                    },
                    availableDates: [],
                    socket: null,
                    focusChart: null,
                    categoryChart: null,
                    hourlyChart: null,
                    tokenChart: null,
                    searchTimeout: null,
                    selectedActivity: null,
                    expandedActivity: null,
                    activityFrames: [],
                    loadingFrames: false
                };
            },
            mounted() {
                this.init();
                // Auto-refresh every 60 seconds
                setInterval(() => {
                    this.refresh();
                }, 60000);
            },
            methods: {
                async init() {
                    await this.loadStats();
                    await this.loadAvailableDates();
                    await this.loadDigest();
                    await this.loadSettings();
                    this.initWebSocket();
                },
                
                initWebSocket() {
                    this.socket = io();
                    
                    this.socket.on('connect', () => {
                        console.log('Connected to server');
                        this.isLive = true;
                    });
                    
                    this.socket.on('disconnect', () => {
                        console.log('Disconnected from server');
                        this.isLive = false;
                    });
                    
                    this.socket.on('new_activity', (data) => {
                        console.log('New activity:', data);
                        this.refresh();
                    });
                },
                
                async loadStats() {
                    try {
                        const response = await fetch('/api/stats');
                        const data = await response.json();
                        this.stats = data;
                    } catch (error) {
                        console.error('Error loading stats:', error);
                    }
                },
                
                async loadDigest(forceRegenerate = false) {
                    this.loadingDigest = true;
                    try {
                        const url = forceRegenerate 
                            ? `/api/digest/${this.digestDate}?force=true`
                            : `/api/digest/${this.digestDate}`;
                        const response = await fetch(url);
                        const data = await response.json();
                        this.digest = data;
                    } catch (error) {
                        console.error('Error loading digest:', error);
                        this.digest = {
                            error: 'Failed to load digest'
                        };
                    } finally {
                        this.loadingDigest = false;
                    }
                },
                
                async regenerateDigest() {
                    await this.loadDigest(true);
                },
                
                previousDigestDay() {
                    const date = new Date(this.digestDate);
                    date.setDate(date.getDate() - 1);
                    this.digestDate = date.toISOString().split('T')[0];
                    this.loadDigest();
                },
                
                nextDigestDay() {
                    const date = new Date(this.digestDate);
                    date.setDate(date.getDate() + 1);
                    // Don't go beyond today
                    const today = new Date();
                    if (date <= today) {
                        this.digestDate = date.toISOString().split('T')[0];
                        this.loadDigest();
                    }
                },
                
                async loadTodayTimeline() {
                    this.loading = true;
                    try {
                        const response = await fetch(`/api/timeline/${this.selectedDate}`);
                        const data = await response.json();
                        this.todayActivities = data.activities || [];
                        
                        // If no activities for today and we have available dates, default to the latest
                        if (this.todayActivities.length === 0 && this.availableDates.length > 0) {
                            const latestDate = this.availableDates[0].date;
                            if (latestDate !== this.selectedDate) {
                                this.selectedDate = latestDate;
                                const latestResponse = await fetch(`/api/timeline/${latestDate}`);
                                const latestData = await latestResponse.json();
                                this.todayActivities = latestData.activities || [];
                            }
                        }
                    } catch (error) {
                        console.error('Error loading timeline:', error);
                    } finally {
                        this.loading = false;
                    }
                },
                
                async loadTimelineByDate() {
                    this.loadingTimeline = true;
                    try {
                        const response = await fetch(`/api/timeline/${this.selectedDate}`);
                        const data = await response.json();
                        this.timelineActivities = data.activities || [];
                    } catch (error) {
                        console.error('Error loading timeline:', error);
                    } finally {
                        this.loadingTimeline = false;
                    }
                },
                
                async loadAnalytics() {
                    try {
                        const response = await fetch(`/api/analytics?days=${this.analyticsDays}`);
                        const data = await response.json();
                        
                        this.renderFocusChart(data.daily_stats);
                        this.renderTokenChart(data.token_usage || []);
                        this.renderCategoryChart(data.category_breakdown);
                        this.renderHourlyChart(data.hourly_breakdown);
                    } catch (error) {
                        console.error('Error loading analytics:', error);
                    }
                },
                
                renderFocusChart(dailyStats) {
                    const ctx = document.getElementById('focusChart');
                    if (!ctx) return;
                    
                    if (this.focusChart) {
                        this.focusChart.destroy();
                    }
                    
                    this.focusChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: dailyStats.map(d => d.date),
                            datasets: [{
                                label: 'Focus %',
                                data: dailyStats.map(d => d.focus_percentage),
                                borderColor: '#E50914',
                                backgroundColor: 'rgba(229, 9, 20, 0.1)',
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    grid: { color: '#222' },
                                    ticks: { color: '#8c8c8c' }
                                },
                                x: {
                                    grid: { color: '#222' },
                                    ticks: { color: '#8c8c8c' }
                                }
                            },
                            plugins: {
                                legend: { labels: { color: '#ffffff' } }
                            }
                        }
                    });
                },
                
                renderTokenChart(tokenUsage) {
                    const ctx = document.getElementById('tokenChart');
                    if (!ctx) return;
                    
                    if (this.tokenChart) {
                        this.tokenChart.destroy();
                    }
                    
                    this.tokenChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: tokenUsage.map(d => d.date),
                            datasets: [
                                {
                                    label: 'Digest Tokens',
                                    data: tokenUsage.map(d => d.digest_tokens),
                                    backgroundColor: '#E50914',
                                    stack: 'stack0'
                                },
                                {
                                    label: 'Annotation Tokens (Placeholder)',
                                    data: tokenUsage.map(d => d.annotation_tokens),
                                    backgroundColor: '#8c8c8c',
                                    stack: 'stack0'
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    grid: { color: '#222' },
                                    ticks: { color: '#8c8c8c' },
                                    title: {
                                        display: true,
                                        text: 'Tokens Used',
                                        color: '#8c8c8c'
                                    }
                                },
                                x: {
                                    grid: { color: '#222' },
                                    ticks: { color: '#8c8c8c' }
                                }
                            },
                            plugins: {
                                legend: { labels: { color: '#ffffff' } },
                                tooltip: {
                                    callbacks: {
                                        footer: (tooltipItems) => {
                                            const total = tooltipItems.reduce((sum, item) => sum + item.parsed.y, 0);
                                            return 'Total: ' + total.toLocaleString() + ' tokens';
                                        }
                                    }
                                }
                            }
                        }
                    });
                },
                
                renderCategoryChart(categoryBreakdown) {
                    const ctx = document.getElementById('categoryChart');
                    if (!ctx) return;
                    
                    if (this.categoryChart) {
                        this.categoryChart.destroy();
                    }
                    
                    this.categoryChart = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: categoryBreakdown.map(c => c.category),
                            datasets: [{
                                data: categoryBreakdown.map(c => c.minutes),
                                backgroundColor: [
                                    '#E50914', '#c41111', '#b81010', 
                                    '#8a8a8a', '#757575', '#666666'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { 
                                    position: 'right',
                                    labels: { color: '#ffffff' }
                                }
                            }
                        }
                    });
                },
                
                renderHourlyChart(hourlyBreakdown) {
                    const ctx = document.getElementById('hourlyChart');
                    if (!ctx) return;
                    
                    if (this.hourlyChart) {
                        this.hourlyChart.destroy();
                    }
                    
                    this.hourlyChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: hourlyBreakdown.map(h => `${h.hour}:00`),
                            datasets: [{
                                label: 'Minutes',
                                data: hourlyBreakdown.map(h => h.minutes),
                                backgroundColor: '#E50914'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    grid: { color: '#222' },
                                    ticks: { color: '#8c8c8c' }
                                },
                                x: {
                                    grid: { color: '#222' },
                                    ticks: { color: '#8c8c8c' }
                                }
                            },
                            plugins: {
                                legend: { labels: { color: '#ffffff' } }
                            }
                        }
                    });
                },
                
                async performSearch() {
                    this.searchLoading = true;
                    try {
                        const params = new URLSearchParams({
                            q: this.searchQuery,
                            category: this.searchCategory,
                            days: 30
                        });
                        
                        const response = await fetch(`/api/search?${params}`);
                        const data = await response.json();
                        this.searchResults = data.results || [];
                    } catch (error) {
                        console.error('Error searching:', error);
                    } finally {
                        this.searchLoading = false;
                    }
                },
                
                debounceSearch() {
                    clearTimeout(this.searchTimeout);
                    this.searchTimeout = setTimeout(() => {
                        if (this.searchQuery.length >= 3) {
                            this.performSearch();
                        }
                    }, 500);
                },
                
                async loadSettings() {
                    try {
                        const response = await fetch('/api/config');
                        const data = await response.json();
                        this.settings = data;
                        
                        // Convert exclude_keywords array to comma-separated text
                        if (this.settings.timeline && this.settings.timeline.exclude_keywords) {
                            this.settings.timeline.exclude_keywords_text = this.settings.timeline.exclude_keywords.join(', ');
                        }
                    } catch (error) {
                        console.error('Error loading settings:', error);
                    }
                },
                
                async saveSettings() {
                    // Validation
                    const errors = [];
                    
                    // Validate capture settings
                    if (!this.settings.capture.capture_interval_seconds || this.settings.capture.capture_interval_seconds <= 0) {
                        errors.push('Capture Interval must be a positive number in seconds (e.g., 900 for 15 minutes)');
                    }
                    if (this.settings.capture.monitor_index === null || this.settings.capture.monitor_index === undefined || this.settings.capture.monitor_index < 0) {
                        errors.push('Monitor Index must be a non-negative number (0 or higher)');
                    }
                    if (!this.settings.capture.retention_days || this.settings.capture.retention_days <= 0) {
                        errors.push('Retention Days must be a positive number');
                    }
                    
                    // Validate annotation settings
                    if (!this.settings.annotation.batch_size || this.settings.annotation.batch_size <= 0) {
                        errors.push('Annotation Batch Size must be a positive number');
                    }
                    if (!this.settings.annotation.prompt || this.settings.annotation.prompt.trim() === '') {
                        errors.push('AI Prompt cannot be empty');
                    }
                    
                    // Validate timeline settings
                    if (!this.settings.timeline.bucket_minutes || this.settings.timeline.bucket_minutes <= 0) {
                        errors.push('Timeline Bucket Minutes must be a positive number');
                    }
                    
                    // Validate digest settings
                    if (!this.settings.digest.interval_seconds || this.settings.digest.interval_seconds <= 0) {
                        errors.push('Digest Interval must be a positive number (in seconds)');
                    }
                    if (!this.settings.digest.ncp_project_id || this.settings.digest.ncp_project_id.trim() === '') {
                        errors.push('NCP Project Name cannot be empty');
                    }
                    
                    // Show validation errors
                    if (errors.length > 0) {
                        alert('Validation Errors:\n\n' + errors.map((e, i) => `${i + 1}. ${e}`).join('\n'));
                        return;
                    }
                    
                    // Prepare settings for save
                    const settingsToSave = JSON.parse(JSON.stringify(this.settings));
                    
                    // Convert exclude_keywords_text to array
                    if (settingsToSave.timeline.exclude_keywords_text !== undefined) {
                        const text = settingsToSave.timeline.exclude_keywords_text.trim();
                        settingsToSave.timeline.exclude_keywords = text ? text.split(',').map(k => k.trim()).filter(k => k) : [];
                        delete settingsToSave.timeline.exclude_keywords_text;
                    }
                    
                    // Save if validation passes
                    try {
                        const response = await fetch('/api/config', {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(settingsToSave)
                        });
                        
                        if (response.ok) {
                            alert('‚úÖ Settings saved successfully!\n\nNote: Restart services for changes to take effect.');
                        } else {
                            const errorData = await response.json();
                            alert('‚ùå Failed to save settings: ' + (errorData.message || 'Unknown error'));
                        }
                    } catch (error) {
                        console.error('Error saving settings:', error);
                        alert('‚ùå Error saving settings: ' + error.message);
                    }
                },
                
                async loadAvailableDates() {
                    try {
                        const response = await fetch('/api/dates');
                        const data = await response.json();
                        this.availableDates = data.dates || [];
                    } catch (error) {
                        console.error('Error loading dates:', error);
                    }
                },
                
                async exportData() {
                    const date = this.selectedDate;
                    window.open(`/api/export/csv?date=${date}`, '_blank');
                },
                
                previousDay() {
                    const date = new Date(this.selectedDate);
                    date.setDate(date.getDate() - 1);
                    this.selectedDate = date.toISOString().split('T')[0];
                    this.loadTimelineByDate();
                },
                
                nextDay() {
                    const date = new Date(this.selectedDate);
                    date.setDate(date.getDate() + 1);
                    this.selectedDate = date.toISOString().split('T')[0];
                    this.loadTimelineByDate();
                },
                
                viewDate(date) {
                    this.selectedDate = date;
                    this.activeTab = 'timeline';
                    this.loadTimelineByDate();
                },
                
                async refresh() {
                    await this.loadStats();
                    await this.loadDigest();
                    if (this.activeTab === 'analytics') {
                        await this.loadAnalytics();
                    }
                },
                
                formatDuration(minutes) {
                    if (minutes < 60) {
                        return `${minutes}m`;
                    }
                    const hours = Math.floor(minutes / 60);
                    const mins = minutes % 60;
                    return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
                },
                
                formatTime(isoString) {
                    const date = new Date(isoString);
                    return date.toLocaleTimeString('en-US', { 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                },
                
                formatDateTime(isoString) {
                    const date = new Date(isoString);
                    return date.toLocaleString('en-US', { 
                        year: 'numeric',
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit', 
                        minute: '2-digit',
                        second: '2-digit'
                    });
                },
                
                async toggleActivityExpand(index) {
                    if (this.expandedActivity === index) {
                        // Collapse
                        this.expandedActivity = null;
                        this.activityFrames = [];
                    } else {
                        // Expand
                        this.expandedActivity = index;
                        this.activityFrames = [];
                        this.loadingFrames = true;
                        
                        const activity = this.timelineActivities[index];
                        
                        try {
                            // Load frames for this activity
                            const date = activity.date || this.selectedDate;
                            const response = await fetch(`/api/frames?date=${date}`);
                            const data = await response.json();
                            
                            // Filter frames within activity time range
                            const startTime = new Date(activity.start_time);
                            const endTime = new Date(activity.end_time);
                            
                            this.activityFrames = data.frames.filter(frame => {
                                const frameTime = new Date(frame.datetime);
                                return frameTime >= startTime && frameTime <= endTime;
                            });
                        } catch (error) {
                            console.error('Error loading frames:', error);
                        } finally {
                            this.loadingFrames = false;
                        }
                    }
                },
                
                getFrameImageUrl(frame) {
                    return `/api/frames/${this.selectedDate}/${frame.timestamp}/image`;
                },
                
                viewFrameFullSize(frame) {
                    const url = this.getFrameImageUrl(frame);
                    window.open(url, '_blank');
                },
                
                renderMarkdown(text) {
                    if (!text) return '';
                    
                    // Configure marked for safe rendering with GitHub Flavored Markdown
                    try {
                        return marked.parse(text, { 
                            breaks: true,  // Convert line breaks to <br>
                            gfm: true      // GitHub Flavored Markdown
                        });
                    } catch (error) {
                        console.error('Error parsing markdown:', error);
                        return text; // Fallback to raw text if parsing fails
                    }
                }
            },
            computed: {
                formattedSelectedDate() {
                    if (!this.selectedDate) return '';
                    const date = new Date(this.selectedDate + 'T12:00:00');
                    return date.toLocaleDateString('en-US', { 
                        weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' 
                    });
                }
            },
            watch: {
                activeTab(newTab) {
                    if (newTab === 'analytics') {
                        this.$nextTick(() => {
                            this.loadAnalytics();
                        });
                    } else if (newTab === 'timeline') {
                        this.loadTimelineByDate();
                    }
                }
            }
        }).mount('#app');
    </script>
</body>
</html>
